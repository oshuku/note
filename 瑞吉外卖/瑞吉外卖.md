## 一、需求总览

- [ ] **后台系统**
        

      	菜品管理（批量删除、起售停售）
      ​	套餐管理（修改、起售停售）
      ​	订单明细

- [ ] **移动端**
        

      	个人中心（退出登录、最新订单查询、历史订单、地址管理-修改地址、地址管理-删除地址）
      
      ​	购物车（删除购物车中的商品)



## 二、需求分析与实现

### 1.后台系统

#### 1.1员工管理

##### 1.1.1账号登录

**需求分析**

- 账号密码登录
  - 使用MD5加密工具类DigestUtils

- 错误提示“登陆失败”
  - 返回失败结果时使用结果类R.java

- 校验账号状态，被锁定账号提示“账号已禁用”
  - 返回失败结果时使用结果类R.java

- 登录成功才能进入主页，否则跳转至登录页面
  - 使用过滤器或者拦截器，判断是否登录，如未登录跳转至登录页面


```java
// 1创建自定义过滤器LoginCheckFilter
// 2在启动类上加入注解@ServletComponentScan
// 3完善过滤器的处理逻辑
/**
 * 判断用户是否登录
 * @author zhuwang
 *
 */
@WebFilter(filterName = "loginCheckFilter", urlPatterns = "/*")
@Slf4j
public class LoginCheckFilter implements Filter{
	// 路径匹配器，支持通配符
	public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		HttpServletRequest httpRequest = (HttpServletRequest) request;
		HttpServletResponse httpResponse = (HttpServletResponse) response;
		
		//1 获取本次请求url路径
		String requestURI = httpRequest.getRequestURI();
		
		log.info("拦截到请求：{}",requestURI);
		
		//创建集合，以下集合内不处理
		String[] urls = new String[] {
				"/employee/login",
				"/employee/logout",
				"/backend/**",
				"/front/**"
		};
		
		//2 判断本次请求是否需要处理
		boolean check = check(urls, requestURI);
		
		//3 如果不需要处理，则直接放行
		if(check) {
			log.info("本次请求无需处理");
			chain.doFilter(httpRequest,httpResponse);
			return;
		}
		
		//4 判断登录状态，已登录则直接放行
		if(httpRequest.getSession().getAttribute("employee") != null) {
			
			log.info("用户已登录，用户id为：{}",httpRequest.getSession().getAttribute("employee"));
			
			chain.doFilter(httpRequest,httpResponse);
			return;
		}
		
		//5 如未登录则返回未登录结果,通过输出流的方式向客户端页面响应数据
		log.info("用户未登录");
		response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
		return;
		
	}

	/**
	 * 路径匹配，检查本次请求是否需要直接放行
	 * @param urls
	 * @param requestURI
	 * @return
	 */
	public boolean check(String[] urls, String requestURI) {
		for(String url : urls) {
			boolean match = PATH_MATCHER.match(url, requestURI);
			if(match) {
				return true;
			}
		}
		return false;
	}

}
```



**流程图**

![](.\imgs\Snipaste_2023-06-09_20-28-21.png)

![image-20230610123018873](C:\Users\zhuwang\AppData\Roaming\Typora\typora-user-images\image-20230610123018873.png)





##### 1.1.2 账号退出

**需求分析**

- 登录成功后跳转到index页面
- 右上角显示用户名
- 点击“退出”按钮后，返回登录界面

**代码逻辑**

- 清理Session中的用户id
- 返回结果



##### 1.1.3 员工添加

**需求分析**

- 输入信息，保存到employee表中
  - 页面发送ajax请求，将输入的数据以json的形式提交到服务端
  - 服务端controller接收数据并调用service将数据进行保存
  - Service调用Mapper操作数据库保存数据
- username字段有唯一约束，用户名不能重复
  - 全局异常捕获



##### 1.1.4 员工信息分页列表

**需求分析**

- 选择每页多少条，分页展示信息
- 上下翻页
- 页码点击跳转
- 指定页码
- 姓名过滤查询
  - 页面发送ajax请求，将分页查询参数（page、pageSize、name）提交到服务器
  - 服务端Controller接收页面提交的数据并调用Service查询数据、
  - Service调用Mapper操作数据库，查询分页数据
  - Controller将查询到的分页数据相应给页面
  - 页面接收到分页数据并通过ElementUI的Table组件展示到页面上
- 页码范围判断

使用MybatisPlus插件前先配置

```java
@Configuration
public class MyBatisPlusConfig {

	@Bean
	public MybatisPlusInterceptor mybatisPlusInterceptor() {
		//1 创建MybatisPlusInterceptor拦截器对象
		MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
		//2 添加分页拦截器
		mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
		return mybatisPlusInterceptor;
	}
}
```

Controller方法

```java
@GetMapping("/page")
	public R<Page> page(int page, int pageSize, String name){
		log.info("page = {}, pageSize = {}, name = {}",page, pageSize, name);
		
		//1 创建分页构造器
		Page<Employee> pageInfo = new Page<>(page, pageSize);
		
		//2 创建条件构造器
		LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
		//3 添加过滤条件
		queryWrapper.like(StringUtils.isNotEmpty(name), Employee::getName, name);
		//4 添加排序条件
		queryWrapper.orderByDesc(Employee::getUpdateTime);
		
		//5 执行查询
		employeeService.page(pageInfo, queryWrapper);
		
		//返回结果
		return R.success(pageInfo);
	}
```



##### 1.1.5 启用/禁用员工账号

**需求分析**

- 禁用状态无法登陆
- 只有管理员可以启用/禁用账号（前端实现）

```html
<el-button
              type="text"
              size="small"
              class="delBut non"
              @click="statusHandle(scope.row)"
              v-if="user === 'admin'"
            >
              {{ scope.row.status == '1' ? '禁用' : '启用' }}
 </el-button>
```

- 处于启用状态的账号，页面显示的是禁用按钮(前端实现)
- 关于员工的Long型id在js处理后精度会丢失问题
  - 使用JacksonObjectMapper，并在WebMvcConfig中配置拓展消息转换器框架
  - Java对象转换为json传给前端时，将Long型转换为String

```java
/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);


        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}
```

```java
@Slf4j
@Configuration //添加Configuration注释，表示这个类是个配置类
public class WebMvcConfig extends WebMvcConfigurationSupport{
	/**
	 * 拓展MVC框架的消息转换器
	 */
	@Override
	protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
		// 创建消息转换器
		MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter(); 
		// 设置对象转换器，底层使用Jackson将Java对象转为json
		messageConverter.setObjectMapper(new JacksonObjectMapper());
		// 将上面的消息转换器对象追加到mvc框架的转换器集合中，注意索引设置为0
		converters.add(0, messageConverter);
	}
}
```



##### 1.1.6 编辑员工信息

**需求分析**

- 编辑页面由员工信息的回显
  - 点击编辑时会传入id参数，利用id查询数据库获取信息

```java
@GetMapping("/{id}")
	public R<Employee> getById(@PathVariable Long id){
		Employee employee = employeeService.getById(id);
		if(employee != null) {
			return R.success(employee);
		}
		return R.error("信息查询失败");
	}
```

- 编辑完信息后保存到数据库



#### 1.2 分类管理

##### 1.2.1 公共字段的自动填充

由MybatisPlus提供公共字段自动填充功能，也就是在插入或者更新的时候为指定字段赋予指定的值，使用它的好处就是可以统一对这些字段进行处理，避免了重复代码

实现步骤：

1. 在实体类的属性上加入@TableField注解，指定自动填充的策略
2. 按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口

```java
	@TableField(fill = FieldFill.INSERT) //插入时填充字段
	private LocalDateTime createTime;
	
	@TableField(fill = FieldFill.INSERT_UPDATE) //插入和更新时填充字段
	private LocalDateTime updateTime;
	
	@TableField(fill = FieldFill.INSERT)//插入时填充字段
	private Long createUser;
	
	@TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段
	private Long updateUser;
```



```java
/**
 * 自定义元数据对象处理器
 * @author zhuwang
 *
 */
@Component
@Slf4j
public class MyMetaObjectHandler implements MetaObjectHandler {
	/**
	 * 插入操作自动填充
	 */
	@Override
	public void insertFill(MetaObject metaObject) {		
		metaObject.setValue("createTime", LocalDateTime.now());
		metaObject.setValue("updateTime", LocalDateTime.now());
        
        //这里写死了，下面借助TreadLocal进行优化
		metaObject.setValue("createUser", new Long(1));
		metaObject.setValue("updateUser", new Long(1));		
	}

	/**
	 * 更新时自动填充
	 */
	@Override
	public void updateFill(MetaObject metaObject) {		
		metaObject.setValue("updateTime", LocalDateTime.now());
		metaObject.setValue("updateUser", new Long(1));
	}

}
```



客户端每次发送的http请求，对应的在服务端都会分配一个新的线程来处理。即同一个请求涉及的方法都属于同一个线程。

什么是ThreadLocal？

> ThreadLocal并不是一个Thread，而是Thread的局部变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。

解决方案：

在LoginCheckFilter的doFilter方法中，获取session中存放的id，然后调用ThreadLocal的set方法存放id值，在MyMetaObjectHandler的updateFill方法中调用ThreadLocal的get方法获取id。



















