## 一、需求总览

- [ ] **后台系统**
        

      	菜品管理（批量删除、起售停售）
      ​	套餐管理（修改、起售停售）
      ​	订单明细

- [ ] **移动端**
        

      	个人中心（退出登录、最新订单查询、历史订单、地址管理-修改地址、地址管理-删除地址）
      
      ​	购物车（删除购物车中的商品)



## 二、需求分析与实现

### 1.后台系统

#### 1.1员工管理

##### 1.1.1账号登录

**需求分析**

- 账号密码登录
  - 使用MD5加密工具类DigestUtils

- 错误提示“登陆失败”
  - 返回失败结果时使用结果类R.java

- 校验账号状态，被锁定账号提示“账号已禁用”
  - 返回失败结果时使用结果类R.java

- 登录成功才能进入主页，否则跳转至登录页面
  - 使用过滤器或者拦截器，判断是否登录，如未登录跳转至登录页面


```java
// 1创建自定义过滤器LoginCheckFilter
// 2在启动类上加入注解@ServletComponentScan
// 3完善过滤器的处理逻辑
/**
 * 判断用户是否登录
 * @author zhuwang
 *
 */
@WebFilter(filterName = "loginCheckFilter", urlPatterns = "/*")
@Slf4j
public class LoginCheckFilter implements Filter{
	// 路径匹配器，支持通配符
	public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {
		HttpServletRequest httpRequest = (HttpServletRequest) request;
		HttpServletResponse httpResponse = (HttpServletResponse) response;
		
		//1 获取本次请求url路径
		String requestURI = httpRequest.getRequestURI();
		
		log.info("拦截到请求：{}",requestURI);
		
		//创建集合，以下集合内不处理
		String[] urls = new String[] {
				"/employee/login",
				"/employee/logout",
				"/backend/**",
				"/front/**"
		};
		
		//2 判断本次请求是否需要处理
		boolean check = check(urls, requestURI);
		
		//3 如果不需要处理，则直接放行
		if(check) {
			log.info("本次请求无需处理");
			chain.doFilter(httpRequest,httpResponse);
			return;
		}
		
		//4 判断登录状态，已登录则直接放行
		if(httpRequest.getSession().getAttribute("employee") != null) {
			
			log.info("用户已登录，用户id为：{}",httpRequest.getSession().getAttribute("employee"));
			
			chain.doFilter(httpRequest,httpResponse);
			return;
		}
		
		//5 如未登录则返回未登录结果,通过输出流的方式向客户端页面响应数据
		log.info("用户未登录");
		response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
		return;
		
	}

	/**
	 * 路径匹配，检查本次请求是否需要直接放行
	 * @param urls
	 * @param requestURI
	 * @return
	 */
	public boolean check(String[] urls, String requestURI) {
		for(String url : urls) {
			boolean match = PATH_MATCHER.match(url, requestURI);
			if(match) {
				return true;
			}
		}
		return false;
	}

}
```



**流程图**

![](.\imgs\Snipaste_2023-06-09_20-28-21.png)

![image-20230610123018873](C:\Users\zhuwang\AppData\Roaming\Typora\typora-user-images\image-20230610123018873.png)





##### 1.1.2 账号退出

**需求分析**

- 登录成功后跳转到index页面
- 右上角显示用户名
- 点击“退出”按钮后，返回登录界面

**代码逻辑**

- 清理Session中的用户id
- 返回结果



##### 1.1.3 员工添加

**需求分析**

- 输入信息，保存到employee表中
  - 页面发送ajax请求，将输入的数据以json的形式提交到服务端
  - 服务端controller接收数据并调用service将数据进行保存
  - Service调用Mapper操作数据库保存数据
- username字段有唯一约束，用户名不能重复
  - 全局异常捕获



##### 1.1.4 员工信息分页列表

**需求分析**

- 选择每页多少条，分页展示信息
- 上下翻页
- 页码点击跳转
- 指定页码
- 姓名过滤查询
  - 页面发送ajax请求，将分页查询参数（page、pageSize、name）提交到服务器
  - 服务端Controller接收页面提交的数据并调用Service查询数据、
  - Service调用Mapper操作数据库，查询分页数据
  - Controller将查询到的分页数据相应给页面
  - 页面接收到分页数据并通过ElementUI的Table组件展示到页面上
- 页码范围判断

使用MybatisPlus插件前先配置

```java
@Configuration
public class MyBatisPlusConfig {

	@Bean
	public MybatisPlusInterceptor mybatisPlusInterceptor() {
		//1 创建MybatisPlusInterceptor拦截器对象
		MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
		//2 添加分页拦截器
		mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
		return mybatisPlusInterceptor;
	}
}
```

Controller方法

```java
@GetMapping("/page")
	public R<Page> page(int page, int pageSize, String name){
		log.info("page = {}, pageSize = {}, name = {}",page, pageSize, name);
		
		//1 创建分页构造器
		Page<Employee> pageInfo = new Page<>(page, pageSize);
		
		//2 创建条件构造器
		LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
		//3 添加过滤条件
		queryWrapper.like(StringUtils.isNotEmpty(name), Employee::getName, name);
		//4 添加排序条件
		queryWrapper.orderByDesc(Employee::getUpdateTime);
		
		//5 执行查询
		employeeService.page(pageInfo, queryWrapper);
		
		//返回结果
		return R.success(pageInfo);
	}
```



##### 1.1.5 启用/禁用员工账号

**需求分析**

- 禁用状态无法登陆
- 只有管理员可以启用/禁用账号（前端实现）

```html
<el-button
              type="text"
              size="small"
              class="delBut non"
              @click="statusHandle(scope.row)"
              v-if="user === 'admin'"
            >
              {{ scope.row.status == '1' ? '禁用' : '启用' }}
 </el-button>
```

- 处于启用状态的账号，页面显示的是禁用按钮(前端实现)
- 关于员工的Long型id在js处理后精度会丢失问题
  - 使用JacksonObjectMapper，并在WebMvcConfig中配置拓展消息转换器框架
  - Java对象转换为json传给前端时，将Long型转换为String

```java
/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);


        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}
```

```java
@Slf4j
@Configuration //添加Configuration注释，表示这个类是个配置类
public class WebMvcConfig extends WebMvcConfigurationSupport{
	/**
	 * 拓展MVC框架的消息转换器
	 */
	@Override
	protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
		// 创建消息转换器
		MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter(); 
		// 设置对象转换器，底层使用Jackson将Java对象转为json
		messageConverter.setObjectMapper(new JacksonObjectMapper());
		// 将上面的消息转换器对象追加到mvc框架的转换器集合中，注意索引设置为0
		converters.add(0, messageConverter);
	}
}
```



##### 1.1.6 编辑员工信息

**需求分析**

- 编辑页面由员工信息的回显
  - 点击编辑时会传入id参数，利用id查询数据库获取信息

```java
@GetMapping("/{id}")
	public R<Employee> getById(@PathVariable Long id){
		Employee employee = employeeService.getById(id);
		if(employee != null) {
			return R.success(employee);
		}
		return R.error("信息查询失败");
	}
```

- 编辑完信息后保存到数据库



#### 1.2 分类管理

##### 1.2.1 公共字段的自动填充

由MybatisPlus提供公共字段自动填充功能，也就是在插入或者更新的时候为指定字段赋予指定的值，使用它的好处就是可以统一对这些字段进行处理，避免了重复代码

实现步骤：

1. 在实体类的属性上加入@TableField注解，指定自动填充的策略
2. 按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口

```java
	@TableField(fill = FieldFill.INSERT) //插入时填充字段
	private LocalDateTime createTime;
	
	@TableField(fill = FieldFill.INSERT_UPDATE) //插入和更新时填充字段
	private LocalDateTime updateTime;
	
	@TableField(fill = FieldFill.INSERT)//插入时填充字段
	private Long createUser;
	
	@TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段
	private Long updateUser;
```



```java
/**
 * 自定义元数据对象处理器
 * @author zhuwang
 *
 */
@Component
@Slf4j
public class MyMetaObjectHandler implements MetaObjectHandler {
	/**
	 * 插入操作自动填充
	 */
	@Override
	public void insertFill(MetaObject metaObject) {		
		metaObject.setValue("createTime", LocalDateTime.now());
		metaObject.setValue("updateTime", LocalDateTime.now());
        
        //这里写死了，下面借助TreadLocal进行优化
		metaObject.setValue("createUser", new Long(1));
		metaObject.setValue("updateUser", new Long(1));		
	}

	/**
	 * 更新时自动填充
	 */
	@Override
	public void updateFill(MetaObject metaObject) {		
		metaObject.setValue("updateTime", LocalDateTime.now());
		metaObject.setValue("updateUser", new Long(1));
	}

}
```



客户端每次发送的http请求，对应的在服务端都会分配一个新的线程来处理。即同一个请求涉及的方法都属于同一个线程。

什么是ThreadLocal？

> ThreadLocal并不是一个Thread，而是Thread的局部变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。

解决方案：

在LoginCheckFilter的doFilter方法中，获取session中存放的id，然后调用ThreadLocal的set方法存放id值，在MyMetaObjectHandler的updateFill方法中调用ThreadLocal的get方法获取id。



基于ThreadLocal封装工具类，用户保存和获取当前登陆用户的id

```java
public class BaseContext {
	private static ThreadLocal<Long> threadLocal = new ThreadLocal<>();
	
	public static void setCurrentId(Long id) {
		threadLocal.set(id);
	}
	
	public static Long getCurrentId() {
		return threadLocal.get();
	}
}
```



自定义元数据对象处理器

```java
@Component
@Slf4j
public class MyMetaObjectHandler implements MetaObjectHandler {

	/**
	 * 插入操作自动填充
	 */
	@Override
	public void insertFill(MetaObject metaObject) {
		//log.info("公共字段自动填充【insert】");
		//log.info(metaObject.toString());
		
		metaObject.setValue("createTime", LocalDateTime.now());
		metaObject.setValue("updateTime", LocalDateTime.now());
		metaObject.setValue("createUser", BaseContext.getCurrentId());
		metaObject.setValue("updateUser", BaseContext.getCurrentId());
		
	}

	/**
	 * 更新时自动填充
	 */
	@Override
	public void updateFill(MetaObject metaObject) {
		//log.info("公共字段自动填充【update】");
		//log.info(metaObject.toString());
		
		metaObject.setValue("updateTime", LocalDateTime.now());
		metaObject.setValue("updateUser", BaseContext.getCurrentId());

	}

}
```



##### 1.2.2 新增分类

**需求分析**

- 两种分类：菜品分类和套餐分类
- 新增表单的字段以json传给controller
- 分类命唯一值不能重复，由全局异常处理器进行处理

**代码实现**

```java
@PostMapping
	public R<String> save(@RequestBody Category category){
		
		categoryService.save(category);
		
		return R.success("新增分类成功");
	}
```



##### 1.2.3 菜品分页查询

同员工分页查询

```java
public class CategoryController {
	@Autowired
	private CategoryService categoryService;
	
	@GetMapping("/page")
	public R<Page<Category>> page(int page, int pageSize){
		log.info("page = {}, pageSize = {}",page,pageSize);
		
		// 创建分页构造器
		Page<Category> pageInfo = new Page<>(page,pageSize);
		
		// 创建条件构造器
		LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
		// 添加排序条件，按sort排序
		queryWrapper.orderByAsc(Category::getSort);
		
		// 进行分页查询
		categoryService.page(pageInfo, queryWrapper);
		
		// 返回结果
		return R.success(pageInfo);
	}
```



##### 1.2.4 删除分类

**需求分析**

- 注意已经关联了菜品的套餐或者分类，不能够删除

![](C:\myData\编程学习\笔记\note\瑞吉外卖\imgs\菜品分类删除.png)

按照上图逻辑在CategoryServiceImpl编写remove方法

```java
/**
	 * 删除分类，删除前需要判断是否有菜品和套餐与该分类有关联
	 */
	@Override
	public void remove(Long id) {
		//添加查询条件，根据id进行查询
		LambdaQueryWrapper<Dish> dishQueryWrapper = new LambdaQueryWrapper<>();
		dishQueryWrapper.eq(Dish::getCategoryId, id);
		
		//查询当前分类是否关联了菜品，如果已关联，抛出一个业务异常
		int count = dishService.count(dishQueryWrapper);
		
		if(count > 0) {
			//有菜品与该分类已有关联,抛业务异常
			throw new CustomException("当前分类下关联了菜品，不能删除");
		}
		
		//添加查询条件，根据id进行查询
		LambdaQueryWrapper<Setmeal> setmealQueryWrapper = new LambdaQueryWrapper<>();
		setmealQueryWrapper.eq(Setmeal::getCategoryId,id);
		
		//查询当前分类是否关联了套餐，如果已关联，抛出一个业务异常
		int count2 = setmealService.count(setmealQueryWrapper);
		
		if(count2 > 0) {
			//有套餐与该分类已有关联,抛业务异常
			throw new CustomException("当前分类下关联了套餐，不能删除");
		}
		
		
		// 正常删除
		super.removeById(id);
	}
```

自定义异常类

```java
/**
 * 自定义业务异常类
 * @author zhuwang
 *
 */
public class CustomException extends RuntimeException{
	public CustomException(String message) {
		super(message);
	}

}
```

异常的处理

```java
/**
	 * 对删除分类已关联菜品、套餐时异常处理
	 * @param ex
	 * @return
	 */
	@ExceptionHandler(CustomException.class)
	public R<String> exceptionHandler(CustomException ex){
		log.info(ex.getMessage());
		
		return R.error(ex.getMessage());
	}
```



##### 1.2.5 修改分类信息

**需求分析**

- 回显分类信息（前端已完成）
- 修改分类信息



#### 1.3 菜品管理

##### 1.3.1 新增菜品

**需求分析**

- 文件上传 - 菜品图片
- 文件下载 - 菜品图片
- 查询分类（下拉框供选择）
- 提交菜品信息
  - 菜品信息 ==》 dish表
  - 口味做法 ==》 dish_flavor表


文件上传时，对页面的form表单有如下要求：

|         method = "post"         |   采用post方式提交数据    |
| :-----------------------------: | :-----------------------: |
| enctype = "multipart/form-data" | 采用multipart格式上传文件 |
|          type = "file"          |  使用input的file控件上传  |



服务端要接收客户端页面上传的文件，通常会使用Apache的两个组件：

- commons-fileupload
- commons-io

Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件，例如：

```java
/**
 * 文件的上传和下载
 * @author zhuwang
 *
 */
@RestController
@Slf4j
@RequestMapping("/common")
public class CommonController {
	
	// 通过注解获取配置文件里的信息
	@Value("${reggie.path}")
	private String basePath;
	
	
	/**
	 * 文件上传
	 * @param file
	 * @return
	 */
	@PostMapping("/upload")
	public R<String> upload(MultipartFile file){//这里参数的名字必须同前端表单提交时Form Data的name一致
		// file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件就会删除
		log.info(file.toString());
		
		// 获取原始文件名
		String originalFilename = file.getOriginalFilename();
		// 截取后缀名
		String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));
		
		// 使用UUID重新生成文件名并连接上后缀名，防止文件名重复造成文件覆盖
		String fileName = UUID.randomUUID().toString() + suffix;
		
		// 创建一个目录对象
		File dir = new File(basePath);
		// 判断当前目录是否存在
		if(!dir.exists()) {
			// 目录不存在需要创建
			dir.mkdirs();
		}
		
		try {
			// 将文件转存到指定位置
			file.transferTo(new File(basePath + fileName));
		} catch (IOException e) {
			e.printStackTrace();
		}
		return R.success(fileName);
	}
```



文件下载介绍

文件下载，也称为download，是指将文件从服务器传输到本地计算机的过程。

通过浏览器进行文件下载，通常有两种表现形式：

- 以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录
- 直接在浏览器中打开

通过浏览器进行文件下载，本质上就是服务端将文件以流的形式回写浏览器的过程。

页面段可以使用<img>标签展示下载的图片：

```html
<img v-if="imageUrl" :src="imageUrl" class="avatar"></img>
```

```java
/**
	 * 文件下载。这里不需要返回值，将文件以流的形式回写浏览器
	 * @param name
	 * @param response
	 */
	@GetMapping("/download")
	public void download(String name, HttpServletResponse response) {
		try {
			// 输入流，通过输入流读取文件内容
			FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));
			
			// 输出流，通过输出流将文件写回浏览器，在浏览器展示图片
			ServletOutputStream outputStream = response.getOutputStream();
			
			// 设置响应的是什么类型的图片
			response.setContentType("image/jpeg");
			
			int len = 0;
			byte[] bytes = new byte[1024];
			while((len = fileInputStream.read(bytes)) != -1) {
				outputStream.write(bytes, 0, len);
				outputStream.flush();
			}
			
			// 关闭资源
			outputStream.close();
			fileInputStream.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
```

查询分类（下拉框供选择）

```java
/**
	 * 新增菜品页面，下拉框展示口味
	 * @param type
	 * @return
	 */
	@GetMapping("/list")
	public R<List<Category>> list(Category category){
		
		LambdaQueryWrapper<Category> lambdaQueryWrapper = new LambdaQueryWrapper<>();
		lambdaQueryWrapper.eq(category.getType() != null, Category::getType, category.getType());
		
		//添加排序条件
		lambdaQueryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);
		
		List<Category> list = categoryService.list(lambdaQueryWrapper);
		
		return R.success(list);
	}
```

提交菜品信息

注意，Dish实体类中并未包含口味信息的字段，但是前端传入的JSON数据中是包含的，所以无法直接封装到Dish实体类中，所以引入DishDto类

```java
@Data
public class DishDto extends Dish {

    private List<DishFlavor> flavors = new ArrayList<>();

    private String categoryName;

    private Integer copies;
}

```

在DishService接口中手动添加自定义方法：

```java
public interface DishService extends IService<Dish>{

	/**
	 * 新增菜品，同时保存口味
	 * @param dishDto
	 */
	public void saveWithFlavor(DishDto dishDto);
}
```

在DishSerivcempl中具体实现，因为涉及到两张表，注意开启事务：

```java
@Service
public class DishServiceImpl extends ServiceImpl<DishMapper, Dish> implements DishService{
	
	@Autowired
	private DishFlavorService dishFlavorService;

	/**
	 * 新增菜品，同时保存口味。操作两张表
	 */
	@Transactional // 涉及两张表，开启事务。启动类上也要做事务配置
	public void saveWithFlavor(DishDto dishDto) {
		// 保存菜品信息到dish表
		this.save(dishDto);
		
		// 保存口味到dish_flavor表
		// 获取口味的列表，但此时列表里并没有该口味对应的菜品的id
		List<DishFlavor> flavors = dishDto.getFlavors();
		
		// 获取菜品id。因为MP是先自动生成id保存到实体之后在保存到数据库，所以可以直接通过实体获取id
		Long dishId = dishDto.getId();
		
		// 利用循环，为list表里的每个口味设置上菜品Id
		for(int i = 0; i < flavors.size(); i++) {
			flavors.get(i).setDishId(dishId);;
		}
		
		// 保存菜品口味数据到菜品口味表dish_flavor
		dishFlavorService.saveBatch(flavors);
	}

	
}
```

在DishController中调用，返回结果：

```java
/**
	 * 新增菜品
	 * @param dishDto
	 * @return
	 */
	@PostMapping
	public R<String> save(@RequestBody DishDto dishDto){
		log.info(dishDto.toString());
		
		dishService.saveWithFlavor(dishDto);
		
		return R.success("新增菜品成功");
	}
```



##### 1.3.2 菜品分页查询

**需求分析**

- 菜品图片的显示（前面的复用）
- 按菜品名称查询
- 菜品分类的显示

```java
/**
	 * 分页展示菜品
	 * @param page
	 * @param pageSize
	 * @return
	 */
	@GetMapping("/page")
	public R<Page<DishDto>> page(int page,int pageSize,String name){
		// 创建分页构造器
		Page<Dish> pageInfo = new Page<>(page,pageSize);
		Page<DishDto> dishDtoPage = new Page<>();
		
		// 创建条件构造器
		LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();
		// 添加过滤条件
		queryWrapper.like(name != null, Dish::getName, name);
		// 添加排序条件
		queryWrapper.orderByDesc(Dish::getUpdateTime);
		
		// 分页查询
		dishService.page(pageInfo, queryWrapper);
		
		// 将结果pageInfo复制给dishDtoPage，除了records
		BeanUtils.copyProperties(pageInfo, dishDtoPage, "records");
		
		// 对pageInfo的records进行处理
		// 获得pageInfo的records
		List<Dish> records = pageInfo.getRecords();
		
		// 准备一个dishDto的空list，用来存放复制的pageInfo的records
		List<DishDto> dishDtoRecords = new ArrayList<>(); 
		
		// 循环遍历pageInfo的records
		for(int i = 0; i < records.size(); i++) {
			// 获得records列表里的dish对象
			Dish dish = records.get(i);
			// 新建一个空dishDto对象，用来存放复制的dish对象里的信息
			DishDto dishDto = new DishDto();
			// 开始复制
			BeanUtils.copyProperties(dish, dishDto);
			
			// 获得dish对象里的分类id
			Long categoryId = dish.getCategoryId();
			// 通过分类id查询分类名
			Category category = categoryService.getById(categoryId);
			
			if(category != null) {
				String categoryName = category.getName();
				// 将查询到的分类名设置给dishDto对象
				dishDto.setCategoryName(categoryName);
			}
			
			// 将dishDto对象存放到列表中
			dishDtoRecords.add(dishDto);
		}
		
		// 将dishDtoRecords设置为dishPage的records
		dishDtoPage.setRecords(dishDtoRecords);
		
		return R.success(dishDtoPage);
	}
```

#####  1.3.3 菜品修改

**需求分析**





















